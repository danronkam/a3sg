class Array
    # Write an `Array#my_inject` method. If my_inject receives no argument, then
    # use the first element of the array as the default accumulator.
    # **Do NOT use the built-in `Array#inject` or `Array#reduce` methods in your 
    # implementation.**
  
    def my_inject(accumulator = nil, &prc)
        if accumulator == nil
            accumulator = self.shift
        end

        self.each do |ele|

            accumulator = prc.call(accumulator, ele)
        end

        accumulator
    end

  end
  
  # Define a method `primes(num)` that returns an array of the first "num" primes.
  # You may wish to use an `is_prime?` helper method.
  
  def is_prime?(num)
    return false if num < 2

    (2...num).each do |factor|
        return false if num % factor == 0
    end

    return true

  end
  
  def primes(num)
    prime_arr = []
    i = 0

    while prime_arr.length < num
        prime_arr << i if is_prime?(i)
        i += 1
    end

    prime_arr
  end
  
  # Write a recursive method that returns the first "num" factorial numbers.
  # Note that the 1st factorial number is 0!, which equals 1. The 2nd factorial
  # is 1!, the 3rd factorial is 2!, etc.
  
  # 1 => [1]
  # 2 => [1, 1]
  # 3 => [1, 1, 2]
  # 4 => [1, 1, 2, 6]
  # 5 => [1, 1, 2, 6, 24]
  
  def factorials_rec(num)
    return [1] if num == 1
    return [1, 1] if num ==2

    arr = factorials_rec(num - 1)
    arr << (num-1) * arr.last

  end
  
  class Array
    # Write an `Array#dups` method that will return a hash containing the indices 
    # of all duplicate elements. The keys are the duplicate elements; the values 
    # are arrays of their indices in ascending order, e.g.
    # [1, 3, 4, 3, 0, 3, 0].dups => { 3 => [1, 3, 5], 0 => [4, 6] }
  
    def dups
        dup_locations = {}

        self.each_with_index do |ele, i|
            if self.count(ele) > 1 && !dup_locations.has_key?(ele)
                dup_locations[ele]  = [i]
            elsif self.count(ele) > 1 && dup_locations.has_key?(ele)
                dup_locations[ele]  += i
            end
        end

        dup_locations
  end
  
  class String
    # Write a `String#symmetric_substrings` method that returns an array of 
    # substrings that are palindromes, e.g. "cool".symmetric_substrings => ["oo"]
    # Only include substrings of length > 1.
  
  
    def symmetric_substrings
        palindromes = []

       (0...self.length).each do |i| 
            (i...self.length).each do |j|
                substring = self[i..j]
                if substring == substring.reverse && substring.length > 1
                    palindromes <<substring
                end
            end
        end
        




        palindromes
  end
  
  class Array
    # Write an `Array#merge_sort` method; it should not modify the original array.
    # **Do NOT use the built in `Array#sort` or `Array#sort_by` methods in your 
    # implementation.**
    
    def merge_sort(&prc)
        return nil if self.empty? # return self if self.length <= 1
        #prc ||= Proc.new {|x, y| x <=> b}
        mid = self.length / 2

        sorted_left = self[0...mid].merge_sort(&prc)
        sorted_right = self[mid+1..-1].merge_sort(&prc)

        Array.merge(sorted, sorted_right, &prc)

    end
  
    private
    def self.merge(left, right, &prc)
        merged = []

        until left.empty? || right.empty?
            case left.first <=> right.first #case prc.call(left.first, right.first)
            when -1
                merged << left.shift
            when 0
                merged << left.shift
            when 1
                merged << right.shift
            end
        end

        merged
    end
  
  end